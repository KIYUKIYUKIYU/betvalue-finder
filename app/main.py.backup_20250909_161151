# -*- coding: utf-8 -*-
"""
app/main.py
BetValue Finder API - MLB/ã‚µãƒƒã‚«ãƒ¼å¯¾å¿œç‰ˆ
ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åŒ–ã•ã‚ŒãŸã‚ªãƒƒã‚ºå‡¦ç†ã¨EVè©•ä¾¡ã‚’ä½¿ç”¨
"""

from __future__ import annotations
from fastapi import FastAPI, HTTPException
from fastapi.staticfiles import StaticFiles
from fastapi.responses import FileResponse, HTMLResponse
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import Optional, List, Dict, Any
import os
import sys
import json
import datetime as dt
import re
import logging
import requests
from app.universal_parser import UniversalBetParser

# ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ«ãƒ¼ãƒˆã‚’ãƒ‘ã‚¹ã«è¿½åŠ 
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# çµ±ä¸€ãƒãƒ³ãƒ‡å¤‰æ›ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ï¼ˆå…¨ç«¶æŠ€å…±é€šãƒ»ä¸å¤‰ï¼‰
from converter.unified_handicap_converter import jp_to_pinnacle, pinnacle_to_jp, HandicapConversionError

# æ–°ã—ã„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
from converter.odds_processor import OddsProcessor
from converter.ev_evaluator import EVEvaluator
from converter.npb_team_mapping import get_npb_english_name, get_npb_full_name, NPB_TEAM_MAPPING
from game_manager.mlb import MLBGameManager
from game_manager.soccer import SoccerGameManager
from game_manager.npb import NPBGameManager
from game_manager.date_resolver import DateResolver
from game_manager import GameIDResolver

# ãƒ­ã‚¬ãƒ¼è¨­å®š
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)

# ãƒ­ã‚¬ãƒ¼è¨­å®š
logger = logging.getLogger(__name__)

app = FastAPI(title="BetValue Finder API", version="2.1.1")

# CORSè¨­å®š
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# é™çš„ãƒ•ã‚¡ã‚¤ãƒ«é…ä¿¡
static_dir = os.path.join(os.path.dirname(__file__), "static")
if not os.path.exists(static_dir):
    os.makedirs(static_dir)

if os.path.exists(static_dir):
    app.mount("/static", StaticFiles(directory=static_dir), name="static")

# --- å®šæ•° ---
MLB_API_BASE = "https://v1.baseball.api-sports.io"
SOCCER_API_BASE = "https://v3.football.api-sports.io"
MLB_LEAGUE_ID = 1
SOCCER_LEAGUES = {
    39: "Premier League",
    140: "La Liga",
    78: "Bundesliga",
    135: "Serie A",
    61: "Ligue 1",
}

PINNACLE_ID = 4
BET365_ID = 2

# --- ãƒ¢ãƒ‡ãƒ« ---
class MapRequest(BaseModel):
    jp: Optional[str] = None
    pinn: Optional[float] = None

class AnalyzePasteRequest(BaseModel):
    text: str
    sport: str = "auto"  # auto/mlb/soccer
    rakeback: float = 0.015
    jp_odds: float = 1.9
    date: Optional[str] = None

class GameEvaluation(BaseModel):
    team_a: str
    team_b: str
    team_a_jp: str
    team_b_jp: str
    fav_team: Optional[str] = None
    fav_team_jp: Optional[str] = None
    jp_line: Optional[str] = None
    pinnacle_line: Optional[float] = None
    # ãƒ•ã‚§ã‚¤ãƒãƒªãƒƒãƒˆå´ã®è©•ä¾¡ï¼ˆ2-wayè¡¨ç¤ºï¼‰
    fav_raw_odds: Optional[float] = None  # ç”Ÿãƒ”ãƒŠã‚¯ãƒ«ã‚ªãƒƒã‚º
    fav_fair_odds: Optional[float] = None  # ãƒãƒ¼ã‚¸ãƒ³é™¤å»ã‚ªãƒƒã‚ºï¼ˆå‚è€ƒç”¨ï¼‰
    fav_ev_pct: Optional[float] = None
    fav_ev_pct_rake: Optional[float] = None
    fav_verdict: Optional[str] = None
    # ã‚¢ãƒ³ãƒ€ãƒ¼ãƒ‰ãƒƒã‚°å´ã®è©•ä¾¡ï¼ˆ2-wayè¡¨ç¤ºï¼‰
    dog_raw_odds: Optional[float] = None  # ç”Ÿãƒ”ãƒŠã‚¯ãƒ«ã‚ªãƒƒã‚º
    dog_fair_odds: Optional[float] = None  # ãƒãƒ¼ã‚¸ãƒ³é™¤å»ã‚ªãƒƒã‚ºï¼ˆå‚è€ƒç”¨ï¼‰
    dog_ev_pct: Optional[float] = None
    dog_ev_pct_rake: Optional[float] = None
    dog_verdict: Optional[str] = None
    # æ¨å¥¨ã¨ã‚¨ãƒ©ãƒ¼
    recommended_side: Optional[str] = None  # "favorite", "underdog", "none"
    error: Optional[str] = None
    error_code: Optional[str] = None
    suggestions: Optional[List[str]] = None

class EvaluateOddsRequest(BaseModel):
    game_id: str
    jp_line: str
    side: str = "home"  # home/away
    rakeback: float = 0.0
    jp_odds: float = 1.9
    sport: str = "mlb"    # mlb/soccer

class BestLinesRequest(BaseModel):
    game_id: str
    top_n: int = 3
    min_ev: Optional[float] = None
    rakeback: float = 0.0
    jp_odds: float = 1.9
    sport: str = "mlb"    # mlb/soccer

class DebugParseRequest(BaseModel):
    text: str
    sport: str = "auto"

class NPBBatchRequest(BaseModel):
    text: str
    rakeback: float = 0.015
    jp_odds: float = 1.9


# --- ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ ---
def get_api_key() -> str:
    """å”¯ä¸€ã®APIã‚­ãƒ¼(API_SPORTS_KEY)ã‚’å–å¾—"""
    key = os.environ.get("API_SPORTS_KEY", "").strip()
    if not key:
        raise HTTPException(status_code=500, detail="API_SPORTS_KEY not configured")
    return key

def build_manager(sport: str, api_key_opt: str = ""):
    sport = (sport or "mlb").lower()
    if sport == "soccer":
        return SoccerGameManager(api_key_opt)
    elif sport == "npb":
        return NPBGameManager(api_key_opt)
    # default
    return MLBGameManager(api_key_opt)

# æ–°ã—ã„çµ±åˆGameIDResolverã®ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
def get_game_resolver() -> GameIDResolver:
    """çµ±åˆGameIDResolverã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å–å¾—"""
    api_key_opt = get_api_key()
    return GameIDResolver(api_key_opt)

def detect_sport(text: str) -> str:
    """ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰ç«¶æŠ€ã‚’è‡ªå‹•åˆ¤å®š"""
    # ã‚µãƒƒã‚«ãƒ¼ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰
    soccer_keywords = [
        "ãƒ‘ãƒ¬ã‚¹", "ãƒ•ã‚©ãƒ¬ã‚¹ãƒˆ", "ã‚·ãƒ†ã‚£", "ãƒ¦ãƒŠã‚¤ãƒ†ãƒƒãƒ‰", "ãƒã‚§ãƒ«ã‚·ãƒ¼",
        "ãƒªãƒãƒ—ãƒ¼ãƒ«", "ã‚¢ãƒ¼ã‚»ãƒŠãƒ«", "ãƒãƒ«ã‚»ãƒ­ãƒŠ", "ãƒ¬ã‚¢ãƒ«", "ãƒã‚¤ã‚¨ãƒ«ãƒ³",
        "ãƒ¦ãƒ™ãƒ³ãƒˆã‚¹", "ãƒŸãƒ©ãƒ³", "ãƒ‘ãƒª", "0/3", "0/5", "0/7"
    ]

    # NPBã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰
    npb_keywords = [
        "å·¨äºº", "ã‚¸ãƒ£ã‚¤ã‚¢ãƒ³ãƒ„", "é˜ªç¥", "ã‚¿ã‚¤ã‚¬ãƒ¼ã‚¹", "ãƒ¤ã‚¯ãƒ«ãƒˆ", "ã‚¹ãƒ¯ãƒ­ãƒ¼ã‚º",
        "DeNA", "ãƒ™ã‚¤ã‚¹ã‚¿ãƒ¼ã‚º", "æ¨ªæµœ", "ä¸­æ—¥", "ãƒ‰ãƒ©ã‚´ãƒ³ã‚º", "åºƒå³¶", "ã‚«ãƒ¼ãƒ—",
        "ã‚½ãƒ•ãƒˆãƒãƒ³ã‚¯", "ãƒ›ãƒ¼ã‚¯ã‚¹", "è¥¿æ­¦", "ãƒ©ã‚¤ã‚ªãƒ³ã‚º", "æ¥½å¤©", "ã‚¤ãƒ¼ã‚°ãƒ«ã‚¹",
        "ãƒ­ãƒƒãƒ†", "ãƒãƒªãƒ¼ãƒ³ã‚º", "æ—¥æœ¬ãƒãƒ ", "æ—¥ãƒãƒ ", "ãƒ•ã‚¡ã‚¤ã‚¿ãƒ¼ã‚º", "ã‚ªãƒªãƒƒã‚¯ã‚¹", "ãƒãƒ•ã‚¡ãƒ­ãƒ¼ã‚º"
    ]

    # MLBã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰
    mlb_keywords = [
        "ãƒ¤ãƒ³ã‚­ãƒ¼ã‚¹", "ãƒ¬ãƒƒãƒ‰ã‚½ãƒƒã‚¯ã‚¹", "ãƒ‰ã‚¸ãƒ£ãƒ¼ã‚¹", "ãƒ¡ãƒƒãƒ„",
        "ã‚«ãƒ–ã‚¹", "ã‚¨ãƒ³ã‚¼ãƒ«ã‚¹", "ã‚¢ã‚¹ãƒˆãƒ­ã‚º", "ãƒ–ãƒ¬ãƒ¼ãƒ–ã‚¹", "ãƒãƒªãƒŠãƒ¼ã‚º"
    ]

    text_lower = text.lower()

    # ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒã‚§ãƒƒã‚¯
    for keyword in soccer_keywords:
        if keyword.lower() in text_lower:
            return "soccer"
    
    for keyword in npb_keywords:
        if keyword.lower() in text_lower:
            return "npb"

    for keyword in mlb_keywords:
        if keyword.lower() in text_lower:
            return "mlb"

    # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯MLB
    return "mlb"

def parse_paste_text(text: str, sport: str = "auto") -> List[Dict]:
    """æ±ç”¨ãƒ‘ãƒ¼ã‚µãƒ¼ã‚’ä½¿ç”¨ã—ãŸè²¼ã‚Šä»˜ã‘ãƒ†ã‚­ã‚¹ãƒˆè§£æ"""
    
    if sport == "auto":
        sport = detect_sport(text)
        logging.info(f"Auto-detected sport: {sport}")
    
    # æ±ç”¨ãƒ‘ãƒ¼ã‚µãƒ¼ã§è§£æ
    parser = UniversalBetParser()
    parsed_games = parser.parse(text)
    
    # æ—¢å­˜ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã«å¤‰æ›
    games = []
    for pg in parsed_games:
        game = {
            "team_a": pg.get('team_a'),
            "team_a_jp": pg.get('team_a'),
            "team_b": pg.get('team_b'),
            "team_b_jp": pg.get('team_b'),
        }
        
        if pg.get('handicap'):
            # ãƒãƒ³ãƒ‡ã‚’ãƒ”ãƒŠã‚¯ãƒ«å€¤ã«å¤‰æ›ï¼ˆçµ±ä¸€å¤‰æ›ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ä½¿ç”¨ï¼‰
            try:
                pinn = jp_to_pinnacle(pg['handicap'])
                game["fav_line_pinnacle"] = pinn
                game["jp_line"] = pg['handicap']
                
                # ãƒ•ã‚§ã‚¤ãƒãƒªãƒƒãƒˆå´ã‚’åˆ¤å®š
                if pg.get('fav_team') == pg.get('team_a'):
                    game["fav_side"] = "a"
                elif pg.get('fav_team') == pg.get('team_b'):
                    game["fav_side"] = "b"
            except HandicapConversionError as e:
                logging.warning(f"ãƒãƒ³ãƒ‡å¤‰æ›ã‚¨ãƒ©ãƒ¼: {pg['handicap']} - {e}")
                continue
        
        games.append(game)
    
    return games

def parse_npb_batch_text(text: str) -> List[Dict]:
    """NPBä¸€æ‹¬ãƒ†ã‚­ã‚¹ãƒˆã®è§£æ"""
    import re
    
    matches = []
    lines = text.strip().split('\n')
    
    # æ™‚åˆ»è¡Œãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
    filtered_lines = []
    for line in lines:
        line = line.strip()
        if line and not re.match(r'^\d{1,2}:\d{2}$', line):  # æ™‚åˆ»ã‚¹ã‚­ãƒƒãƒ—
            filtered_lines.append(line)
    
    # 2è¡Œãšã¤ãƒšã‚¢ã§å‡¦ç†
    i = 0
    while i < len(filtered_lines):
        if i + 1 < len(filtered_lines):
            team1_line = filtered_lines[i]
            team2_line = filtered_lines[i + 1]
            
            match_data = parse_npb_match_pair(team1_line, team2_line)
            if match_data:
                matches.append(match_data)
            
            i += 2
        else:
            i += 1
    
    return matches

def parse_npb_match_pair(team1_line: str, team2_line: str) -> Optional[Dict]:
    """NPB 2ãƒãƒ¼ãƒ ãƒšã‚¢ã®è§£æ"""
    import re
    
    # ãƒãƒ³ãƒ‡æ¤œå‡º
    handicap_pattern = r'^(.+?)<(.+?)>$'
    
    team1_match = re.match(handicap_pattern, team1_line.strip())
    team2_match = re.match(handicap_pattern, team2_line.strip())
    
    if team1_match:
        home_team = team1_match.group(1).strip()
        away_team = team2_line.strip()
        handicap = team1_match.group(2).strip()
        side = 'home'
    elif team2_match:
        home_team = team2_match.group(1).strip()
        away_team = team1_line.strip()
        handicap = team2_match.group(2).strip()
        side = 'away'
    else:
        home_team = team1_line.strip()
        away_team = team2_line.strip()
        handicap = "0"
        side = 'home'
    
    # NPBæ­£å¼åå¤‰æ›
    home_full = get_npb_full_name(home_team)
    away_full = get_npb_full_name(away_team)
    
    # è‹±èªåå¤‰æ›
    home_english = get_npb_english_name(home_full) if home_full else None
    away_english = get_npb_english_name(away_full) if away_full else None
    
    if not home_english or not away_english:
        logging.warning(f"Unknown NPB teams: {home_team} vs {away_team}")
        return None
    
    return {
        'home_team_jp': home_team,
        'away_team_jp': away_team,
        'home_team_full': home_full,
        'away_team_full': away_full,
        'home_team_en': home_english,
        'away_team_en': away_english,
        'handicap': handicap,
        'side': side,
        'raw_input': f"{team1_line} vs {team2_line}"
    }

def evaluate_npb_match_with_defaults(match: Dict, rakeback: float, jp_odds: float) -> Dict:
    """NPBãƒãƒƒãƒã‚’è©•ä¾¡ï¼ˆè¨ˆç®—ãƒ™ãƒ¼ã‚¹ã‚ªãƒƒã‚ºä½¿ç”¨ï¼‰"""
    
    # è¨ˆç®—ãƒ™ãƒ¼ã‚¹ã®ã‚ªãƒƒã‚ºç”Ÿæˆï¼ˆå›ºå®šå€¤å»ƒæ­¢ï¼‰
    # HandicapInterpolatorã‚’ä½¿ç”¨ã—ã¦ãƒ”ãƒŠã‚¯ãƒ«å´æä¾›ã•ã‚Œãªã„ãƒ©ã‚¤ãƒ³ã¯ç·šå½¢è£œé–“ã§è¨ˆç®—
    from converter.handicap_interpolator import HandicapInterpolator
    interpolator = HandicapInterpolator()
    
    # åŸºæœ¬ã¨ãªã‚‹ãƒ”ãƒŠã‚¯ãƒ«ã‚ªãƒƒã‚ºï¼ˆå®Ÿéš›ã®APIãƒ‡ãƒ¼ã‚¿ãŒãªã„å ´åˆã®æœ€å°é™ï¼‰
    # ã“ã‚Œã‚‰ã‚‚æœ¬æ¥ã¯ãƒ”ãƒŠã‚¯ãƒ«APIã‹ã‚‰å–å¾—ã™ã¹ãã ãŒã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå‡¦ç†ã¨ã—ã¦è¨­å®š
    base_odds_data = {
        -2.0: (3.0, 1.4),    # å¤§ããªãŠæ°—ã«å…¥ã‚Š
        -1.5: (2.5, 1.6),    # ä¸­ç¨‹åº¦ã®ãŠæ°—ã«å…¥ã‚Š  
        1.5: (1.6, 2.5),     # ä¸­ç¨‹åº¦ã®ã‚¢ãƒ³ãƒ€ãƒ¼ãƒ‰ãƒƒã‚°
        2.0: (1.4, 3.0)      # å¤§ããªã‚¢ãƒ³ãƒ€ãƒ¼ãƒ‰ãƒƒã‚°
    }
    
    # å¿…è¦ãªãƒ©ã‚¤ãƒ³ç¯„å›²ã‚’è¨ˆç®—ãƒ™ãƒ¼ã‚¹ã§ç”Ÿæˆ
    target_lines = [-1.5, -1.0, -0.5, 0.0, 0.5, 1.0, 1.5]
    calculated_odds = {}
    
    for line in target_lines:
        # ç·šå½¢è£œé–“ã§ã‚ªãƒƒã‚ºã‚’è¨ˆç®—
        odds_result = interpolator.calculate_fair_probs_for_line(
            base_odds_data, line, allow_interpolation=True
        )
        if odds_result:
            home_prob, away_prob = odds_result
            # å…¬æ­£å‹ç‡ã‹ã‚‰é©æ­£ã‚ªãƒƒã‚ºã‚’é€†ç®—ï¼ˆãƒãƒ¼ã‚¸ãƒ³è€ƒæ…®ï¼‰
            margin = 0.05  # 5%ã®ãƒãƒ¼ã‚¸ãƒ³ã‚’æƒ³å®š
            home_odds = (1.0 / home_prob) * (1 + margin)
            away_odds = (1.0 / away_prob) * (1 + margin)
            calculated_odds[line] = (round(home_odds, 2), round(away_odds, 2))
        else:
            # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼šå¯¾ç§°çš„ãªç¢ºç‡ã§è¨ˆç®—
            calculated_odds[line] = (1.90, 1.90)
    
    # è¨ˆç®—ã•ã‚ŒãŸã‚ªãƒƒã‚ºã§ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’æ§‹ç¯‰
    default_lines = {
        'ml': {'home': calculated_odds[0.0][0], 'away': calculated_odds[0.0][1]},
        'hcap': [
            {'line': line, 'home': calculated_odds[line][0], 'away': calculated_odds[line][1]}
            for line in target_lines
        ]
    }
    
    # EVEvaluatorã‚’ä½¿ç”¨ï¼ˆãƒ¡ã‚¤ãƒ³ã‚·ã‚¹ãƒ†ãƒ ã®ãƒ­ã‚¸ãƒƒã‚¯ã€ãƒ¬ãƒ¼ã‚­ãƒãƒƒã‚¯è¾¼ã¿ï¼‰
    ev_evaluator = EVEvaluator(jp_odds=jp_odds, rakeback=rakeback)
    
    # æ—¥æœ¬å¼ãƒãƒ³ãƒ‡â†’ãƒ”ãƒŠã‚¯ãƒ«å¤‰æ›
    jp_handicap = match['handicap']
    side = match['side']
    
    # ãƒãƒ³ãƒ‡å¤‰æ›ï¼ˆãƒ•ã‚§ã‚¤ãƒãƒªãƒƒãƒˆ/ã‚¢ãƒ³ãƒ€ãƒ¼ãƒ‰ãƒƒã‚°ç¬¦å·å‡¦ç†ä¿®æ­£ç‰ˆï¼‰
    try:
        if jp_handicap == "06":
            base_line = 0.6
        elif jp_handicap == "1.0":
            base_line = 1.0
        elif jp_handicap == "0":
            base_line = 0.0
        else:
            base_line = float(jp_handicap.replace("åŠ", ".5"))
        
        # ãƒ•ã‚§ã‚¤ãƒãƒªãƒƒãƒˆ/ã‚¢ãƒ³ãƒ€ãƒ¼ãƒ‰ãƒƒã‚°ã«å¿œã˜ã¦ç¬¦å·ã‚’æ±ºå®šï¼ˆãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã®è¡¨ç¤ºã«åŸºã¥ã„ã¦ä¿®æ­£ï¼‰
        if side == "away":  # ãƒ•ã‚§ã‚¤ãƒãƒªãƒƒãƒˆï¼ˆãƒ‘ãƒ‰ãƒ¬ã‚¹ãªã©ï¼‰
            pinnacle_line = -base_line  # ãƒã‚¤ãƒŠã‚¹ç¬¦å·
        else:  # ã‚¢ãƒ³ãƒ€ãƒ¼ãƒ‰ãƒƒã‚°ï¼ˆãƒ­ãƒƒã‚­ãƒ¼ã‚ºãªã©ï¼‰
            pinnacle_line = +base_line  # ãƒ—ãƒ©ã‚¹ç¬¦å·
            
    except:
        pinnacle_line = 0.0
    
    # ã‚ªãƒƒã‚ºãƒ‡ãƒ¼ã‚¿å½¢å¼å¤‰æ›ï¼ˆhcapãƒªã‚¹ãƒˆã‹ã‚‰è¾æ›¸ã¸ï¼‰
    odds_dict = {}
    for hcap_item in default_lines['hcap']:
        odds_dict[hcap_item['line']] = (hcap_item['home'], hcap_item['away'])
    
    # EVè©•ä¾¡å®Ÿè¡Œï¼ˆæ­£ã—ã„ãƒ¡ã‚½ãƒƒãƒ‰ã‚·ã‚°ãƒãƒãƒ£ï¼‰
    return ev_evaluator.evaluate_single_line(
        odds_data=odds_dict,
        target_line=pinnacle_line,
        side=side
    )

def _norm_name(s: str) -> str:
    return (
        (s or "")
        .lower()
        .replace(".", "")
        .replace(" ", "")
        .replace("-", "")
        .replace("_", "")
    )

def suggest_matchups(teams: List[str], games: Optional[List[Dict]]) -> List[str]:
    """ä¼¼ãŸã‚«ãƒ¼ãƒ‰å€™è£œã‚’è¿”ã™ï¼ˆæœ€å¤§5ä»¶ï¼‰"""
    if not games:
        return []
    ta, tb = teams[0], teams[1]
    na = _norm_name(ta)
    nb = _norm_name(tb)
    suggestions: List[str] = []
    for g in games:
        home = g.get("home") or g.get("raw", {}).get("teams", {}).get("home", {}).get("name", "")
        away = g.get("away") or g.get("raw", {}).get("teams", {}).get("away", {}).get("name", "")
        hj = g.get("home_jp") or ""
        aj = g.get("away_jp") or ""
        for H, A in ((home, away), (hj, aj)):
            nh = _norm_name(H)
            na_ = _norm_name(A)
            # ã©ã¡ã‚‰ã‹ãŒéƒ¨åˆ†ä¸€è‡´ã—ã¦ã„ã‚Œã°å€™è£œã«
            if (na in nh or nh in na) or (nb in na_ or na_ in nb):
                label = f"{g.get('home') or H} vs {g.get('away') or A}"
                if label not in suggestions:
                    suggestions.append(label)
                break
        if len(suggestions) >= 5:
            break
    return suggestions

# --- ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ ---

@app.get("/", response_class=HTMLResponse)
async def root():
    """ãƒ«ãƒ¼ãƒˆï¼šindex.htmlã‚’è¿”ã™"""
    index_path = os.path.join(static_dir, "index.html")
    if os.path.exists(index_path):
        return FileResponse(index_path, media_type="text/html")

    # index.htmlãŒãªã„å ´åˆã¯ç°¡å˜ãªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
    return HTMLResponse(content="""
    <html>
        <head><title>BetValue Finder</title></head>
        <body>
            <h1>BetValue Finder API v2.0</h1>
            <p>API is running with modularized odds processing and EV evaluation.</p>
            <p><a href="/docs">API Documentation</a></p>
        </body>
    </html>
    """)

@app.post("/map")
async def map_endpoint(req: MapRequest):
    """æ—¥æœ¬å¼â‡”ãƒ”ãƒŠã‚¯ãƒ«å€¤ã®ç›¸äº’å¤‰æ›"""
    if req.jp:
        try:
            pinn = jp_to_pinnacle(req.jp)
            return {"jp": req.jp, "pinnacle": pinn}
        except HandicapConversionError as e:
            return {"error": f"æœªå¯¾å¿œã®æ—¥æœ¬å¼è¡¨è¨˜: {req.jp} - {e}"}

    if req.pinn is not None:
        try:
            jp = pinnacle_to_jp(req.pinn)
            return {"pinnacle": req.pinn, "jp": jp}
        except Exception as e:
            return {"error": str(e)}

    return {"error": "jp ã¾ãŸã¯ pinn ã®ã©ã¡ã‚‰ã‹ã‚’æŒ‡å®šã—ã¦ãã ã•ã„"}

@app.post("/analyze_paste", response_model=List[GameEvaluation])
async def analyze_paste_endpoint(req: AnalyzePasteRequest):
    """è²¼ã‚Šä»˜ã‘ãƒ†ã‚­ã‚¹ãƒˆã‚’è§£æã—ã¦EVè¨ˆç®—ï¼ˆä¸¡å´è©•ä¾¡ç‰ˆï¼‰"""
    try:
        # ãƒ†ã‚­ã‚¹ãƒˆã‚’ãƒ‘ãƒ¼ã‚¹ï¼ˆAPIã‚­ãƒ¼ã¯å¿…è¦æ™‚ã®ã¿å‚ç…§ï¼‰
        games = parse_paste_text(req.text, req.sport)

        if not games:
            raise HTTPException(status_code=400, detail="è©¦åˆãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")

        # åˆ¤å®šã‚¹ãƒãƒ¼ãƒ„
        sport = req.sport if req.sport != "auto" else detect_sport(req.text)

        # GameManagerã¨ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åˆæœŸåŒ–ï¼ˆAPIã‚­ãƒ¼ã¯ä»»æ„: ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã®ã¿ã§ã‚‚å‹•ä½œï¼‰
        api_key_opt = os.environ.get("API_SPORTS_KEY", "").strip()
        manager = build_manager(sport, api_key_opt)
        odds_processor = OddsProcessor()
        ev_evaluator = EVEvaluator(jp_odds=req.jp_odds, rakeback=req.rakeback)

        results = []

        # ãƒãƒƒãƒãƒ³ã‚°ã«ä½¿ã†è©¦åˆãƒªã‚¹ãƒˆï¼ˆæ—¥ä»˜è§£æ±ºæ©Ÿèƒ½ä»˜ãï¼‰
        match_games = None
        if req.date:
            try:
                # DateResolverã§é©åˆ‡ãªAPIæ—¥ä»˜ã‚’å–å¾—
                resolver = DateResolver()
                api_dates = resolver.get_api_dates(sport, req.date)
                
                # è¤‡æ•°æ—¥ä»˜ã®å ´åˆã¯æœ€åˆã«è¦‹ã¤ã‹ã£ãŸã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ä½¿ç”¨
                for api_date in api_dates:
                    ymd = api_date.replace("-", "")
                    try:
                        cache = manager.load_cache(f"games_{ymd}.json")
                        if cache and isinstance(cache, dict):
                            match_games = cache.get("games") or cache
                            print(f"ğŸ“… Using cached games for {api_date} (from card date {req.date})")
                            break
                    except Exception:
                        continue
                        
                if not match_games:
                    print(f"âš ï¸ No cached games found for {sport} card date {req.date} (tried: {api_dates})")
                    
            except Exception as e:
                print(f"âŒ Date resolution error: {e}")
                match_games = None

        for game in games:
            # åŸºæœ¬çš„ãªè©•ä¾¡çµæœã‚’ä½œæˆ
            eval_result = GameEvaluation(
                team_a=game["team_a"],
                team_b=game["team_b"],
                team_a_jp=game.get("team_a_jp", game["team_a"]),
                team_b_jp=game.get("team_b_jp", game["team_b"])
            )

            # è©¦åˆã‚’æ¤œç´¢
            matched_game = manager.match_teams([game["team_a"], game["team_b"]], games=match_games)

            if not matched_game:
                eval_result.error = "è©¦åˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"
                eval_result.error_code = "GAME_NOT_FOUND"
                # å€™è£œã®æç¤º
                eval_result.suggestions = suggest_matchups([game["team_a"], game["team_b"]], match_games or manager.load_latest_cache())
                results.append(eval_result)
                continue

            # ãƒ•ã‚§ã‚¤ãƒãƒªãƒƒãƒˆå´ã®å‡¦ç†
            # ğŸš¨ æ¡ä»¶åˆ†å²ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°
            logger.info(f"ğŸš¨ CONDITION CHECK - fav_side: {game.get('fav_side')}, fav_line_pinnacle: {game.get('fav_line_pinnacle')}")
            if game.get("fav_side") and game.get("fav_line_pinnacle"):
                logger.info(f"ğŸš¨ TAKING MAIN PATH (with fav_side and fav_line_pinnacle)")
                # ğŸ” ãƒ‡ãƒãƒƒã‚°: team_a/team_b ã¨fav_sideã®é–¢ä¿‚ã‚’ç¢ºèª
                logger.info(f"ğŸ” DEBUG - team_a: {game['team_a']}, team_b: {game['team_b']}")
                logger.info(f"ğŸ” DEBUG - matched_game home: {matched_game['home']}, away: {matched_game['away']}")
                if game["fav_side"] == "a":
                    eval_result.fav_team = game["team_a"]
                    eval_result.fav_team_jp = game["team_a_jp"]
                    fav_side = "home" if matched_game["home"] == eval_result.fav_team else "away"
                    dog_team = game["team_b"]
                    dog_team_jp = game["team_b_jp"]
                    logger.info(f"ğŸ” DEBUG - fav_side=a: fav_team={eval_result.fav_team} â†’ fav_side={fav_side}")
                else:
                    eval_result.fav_team = game["team_b"]
                    eval_result.fav_team_jp = game["team_b_jp"]
                    fav_side = "home" if matched_game["home"] == eval_result.fav_team else "away"
                    dog_team = game["team_a"]
                    dog_team_jp = game["team_a_jp"]
                    logger.info(f"ğŸ” DEBUG - fav_side=b: fav_team={eval_result.fav_team} â†’ fav_side={fav_side}")

                # ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°ï¼ˆãƒ•ã‚§ã‚¤ãƒãƒªãƒƒãƒˆ/ã‚¢ãƒ³ãƒ€ãƒ¼ãƒ‰ãƒƒã‚°åˆ¤å®šç¢ºèªç”¨ï¼‰
                logging.debug(f"Favorite determination: {eval_result.fav_team_jp}({eval_result.fav_team}) = {fav_side}, "
                             f"API game: {matched_game['away']} @ {matched_game['home']}")

                eval_result.jp_line = game.get("jp_line")
                eval_result.pinnacle_line = game["fav_line_pinnacle"]

                # ã‚¢ãƒ³ãƒ€ãƒ¼ãƒ‰ãƒƒã‚°å´ã‚’åˆ¤å®š
                dog_side = "away" if fav_side == "home" else "home"

                # ã‚ªãƒƒã‚ºã‚’å–å¾—
                odds_data = manager.fetch_odds(matched_game["id"])

                if not odds_data:
                    eval_result.error = "ã‚ªãƒƒã‚ºãŒå–å¾—ã§ãã¾ã›ã‚“"
                    eval_result.error_code = "NO_ODDS"
                    results.append(eval_result)
                    continue

                # ã‚ªãƒƒã‚ºã‚’å‡¦ç†
                line_data = odds_processor.prepare_line_data(odds_data)

                if not line_data:
                    eval_result.error = "ãƒãƒ³ãƒ‡ã‚ªãƒƒã‚ºãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"
                    eval_result.error_code = "NO_HANDICAP_ODDS"
                    results.append(eval_result)
                    continue

                # ãƒãƒ³ãƒ‡ãƒ©ã‚¤ãƒ³ã®ä¸¡å´ã‚’æ­£ã—ãè©•ä¾¡ï¼ˆ2-wayè¡¨ç¤ºã‚·ã‚¹ãƒ†ãƒ ï¼‰
                # ä¿®æ­£: Home/Away + Favoriteçµ„ã¿åˆã‚ã›ã§ãƒ©ã‚¤ãƒ³æ±ºå®š
                if fav_side == "away":
                    # Away Favorite â†’ ä¸¡ãƒãƒ¼ãƒ  +1.5ãƒ©ã‚¤ãƒ³ä½¿ç”¨
                    target_line = +eval_result.pinnacle_line
                else:
                    # Home Favorite â†’ ä¸¡ãƒãƒ¼ãƒ  -1.5ãƒ©ã‚¤ãƒ³ä½¿ç”¨  
                    target_line = -eval_result.pinnacle_line
                
                # ä¸¡ãƒãƒ¼ãƒ åŒã˜ãƒ©ã‚¤ãƒ³ã‚’ä½¿ç”¨
                fav_target_line = target_line
                dog_target_line = target_line
                
                # ğŸ”§ ä¿®æ­£ç¢ºèªç”¨ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°
                logger.info(f"ğŸ”§ 2-WAY DISPLAY - pinnacle_line: {eval_result.pinnacle_line}")
                logger.info(f"ğŸ”§ 2-WAY DISPLAY - target_line: {target_line} (fav_side: {fav_side})")
                logger.info(f"ğŸ”§ 2-WAY DISPLAY - dog_target_line: {dog_target_line} (side: {dog_side})")
                
                # ãƒ•ã‚§ã‚¤ãƒãƒªãƒƒãƒˆå´ã®ç°¡ç•¥åŒ–EVè©•ä¾¡ï¼ˆå‹ç‡è¨ˆç®—ãªã—ï¼‰
                fav_evaluation = ev_evaluator.evaluate_simplified_line(
                    line_data,
                    fav_target_line,
                    fav_side
                )

                # ã‚¢ãƒ³ãƒ€ãƒ¼ãƒ‰ãƒƒã‚°å´ã®ç°¡ç•¥åŒ–EVè©•ä¾¡ï¼ˆå‹ç‡è¨ˆç®—ãªã—ï¼‰
                dog_evaluation = ev_evaluator.evaluate_simplified_line(
                    line_data,
                    dog_target_line,
                    dog_side
                )

                # ãƒ•ã‚§ã‚¤ãƒãƒªãƒƒãƒˆå´ã®çµæœã‚’è¨­å®šï¼ˆ2-wayè¡¨ç¤ºï¼‰
                eval_result.fav_raw_odds = fav_evaluation.get("raw_odds")
                eval_result.fav_fair_odds = fav_evaluation.get("fair_odds")
                eval_result.fav_ev_pct = fav_evaluation.get("ev_pct")
                eval_result.fav_ev_pct_rake = fav_evaluation.get("ev_pct_rake")
                eval_result.fav_verdict = fav_evaluation.get("verdict")

                # ã‚¢ãƒ³ãƒ€ãƒ¼ãƒ‰ãƒƒã‚°å´ã®çµæœã‚’è¨­å®šï¼ˆ2-wayè¡¨ç¤ºï¼‰
                eval_result.dog_raw_odds = dog_evaluation.get("raw_odds")
                eval_result.dog_fair_odds = dog_evaluation.get("fair_odds")
                eval_result.dog_ev_pct = dog_evaluation.get("ev_pct")
                eval_result.dog_ev_pct_rake = dog_evaluation.get("ev_pct_rake")
                eval_result.dog_verdict = dog_evaluation.get("verdict")

                # ã‚µãƒ‹ãƒ†ã‚£ãƒã‚§ãƒƒã‚¯ - ã‚ªãƒƒã‚ºãŒåˆç†çš„ç¯„å›²å†…ã‹ãƒã‚§ãƒƒã‚¯
                fav_odds = eval_result.fav_raw_odds
                dog_odds = eval_result.dog_raw_odds
                if fav_odds and dog_odds:
                    if not (1.1 <= fav_odds <= 4.0) or not (1.1 <= dog_odds <= 4.0):
                        logger.warning(f"âš ï¸ UNUSUAL ODDS - fav: {fav_odds}, dog: {dog_odds}, game: {eval_result.game_id}")

                # æ¨å¥¨å´ã‚’æ±ºå®šï¼ˆEVãŒé«˜ã„æ–¹ï¼‰
                if eval_result.fav_ev_pct_rake and eval_result.dog_ev_pct_rake:
                    if eval_result.fav_ev_pct_rake > eval_result.dog_ev_pct_rake:
                        eval_result.recommended_side = "favorite"
                    elif eval_result.dog_ev_pct_rake > eval_result.fav_ev_pct_rake:
                        eval_result.recommended_side = "underdog"
                    else:
                        eval_result.recommended_side = "none"
                
                # ã‚¨ãƒ©ãƒ¼ãƒã‚§ãƒƒã‚¯
                if fav_evaluation.get("error") or dog_evaluation.get("error"):
                    eval_result.error = f"è©•ä¾¡ã‚¨ãƒ©ãƒ¼: {fav_evaluation.get('error', '')} {dog_evaluation.get('error', '')}"
                    eval_result.error_code = "EVALUATION_ERROR"
            else:
                logger.info(f"ğŸš¨ TAKING ELSE PATH (NO fav_side or fav_line_pinnacle)")
                eval_result.error = "ãƒãƒ³ãƒ‡ãŒæŒ‡å®šã•ã‚Œã¦ã„ã¾ã›ã‚“"
                eval_result.error_code = "NO_HANDICAP"

            results.append(eval_result)

        return results

    except HTTPException:
        raise
    except Exception as e:
        logging.error(f"Error in analyze_paste: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/evaluate_odds")
async def evaluate_odds_endpoint(req: EvaluateOddsRequest):
    """ç‰¹å®šã‚²ãƒ¼ãƒ ãƒ»ãƒ©ã‚¤ãƒ³ã®EVè©•ä¾¡"""
    try:
        sport = (req.sport or "mlb").lower()
        api_key = get_api_key()

        # GameManagerã¨ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åˆæœŸåŒ–
        manager = build_manager(sport, api_key)
        odds_processor = OddsProcessor()
        ev_evaluator = EVEvaluator(jp_odds=req.jp_odds, rakeback=req.rakeback)

        # ã‚ªãƒƒã‚ºå–å¾—
        odds_data = manager.fetch_odds(req.game_id)

        if not odds_data:
            raise HTTPException(status_code=404, detail="Odds not found for this game")

        # ã‚ªãƒƒã‚ºã‚’å‡¦ç†
        line_data = odds_processor.prepare_line_data(odds_data)

        if not line_data:
            raise HTTPException(status_code=404, detail="No handicap odds available")

        # æ—¥æœ¬å¼ã‚’ãƒ”ãƒŠã‚¯ãƒ«å€¤ã«å¤‰æ›ï¼ˆçµ±ä¸€å¤‰æ›ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ä½¿ç”¨ï¼‰
        try:
            pinnacle_value = jp_to_pinnacle(req.jp_line)
        except HandicapConversionError as e:
            raise HTTPException(status_code=400, detail=f"Invalid JP line: {req.jp_line} - {e}")

        # EVè©•ä¾¡
        result = ev_evaluator.evaluate_single_line(
            line_data,
            pinnacle_value,
            req.side
        )

        return result

    except HTTPException:
        raise
    except Exception as e:
        logging.error(f"Error in evaluate_odds: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/find_best_lines")
async def find_best_lines_endpoint(req: BestLinesRequest):
    """ç‰¹å®šã‚²ãƒ¼ãƒ ã®æœ€è‰¯ãƒ©ã‚¤ãƒ³ã‚’æ¤œç´¢"""
    try:
        sport = (req.sport or "mlb").lower()
        api_key = get_api_key()

        # GameManagerã¨ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åˆæœŸåŒ–
        manager = build_manager(sport, api_key)
        odds_processor = OddsProcessor()
        ev_evaluator = EVEvaluator(jp_odds=req.jp_odds, rakeback=req.rakeback)

        # ã‚ªãƒƒã‚ºå–å¾—
        odds_data = manager.fetch_odds(req.game_id)

        if not odds_data:
            raise HTTPException(status_code=404, detail="Odds not found for this game")

        # ã‚ªãƒƒã‚ºã‚’å‡¦ç†
        line_data = odds_processor.prepare_line_data(odds_data)

        if not line_data:
            raise HTTPException(status_code=404, detail="No handicap odds available")

        # æœ€è‰¯ãƒ©ã‚¤ãƒ³ã‚’æ¤œç´¢
        best_lines = ev_evaluator.find_best_lines(
            line_data,
            top_n=req.top_n,
            min_ev=req.min_ev
        )

        return best_lines

    except HTTPException:
        raise
    except Exception as e:
        logging.error(f"Error in find_best_lines: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/health")
async def health_check():
    """ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯"""
    api_key = os.environ.get("API_SPORTS_KEY", "").strip()
    return {
        "status": "healthy",
        "version": "2.1.1",
        "api_key_configured": bool(api_key),
        "modules": {
            "odds_processor": "OK",
            "ev_evaluator": "OK",
            "game_manager": "OK"
        },
        "timestamp": dt.datetime.utcnow().isoformat()
    }

@app.get("/api_status")
async def api_status():
    """APIã‚­ãƒ¼è¨­å®šçŠ¶æ³ã¨ç–é€šãƒ†ã‚¹ãƒˆï¼ˆè»½é‡ï¼‰ã‚’è¿”ã™ã€‚
    - api_key_configured: True/False
    - api_key_masked: å…ˆé ­4æ¡ã®ã¿è¡¨ç¤º + é•·ã•
    - mlb/soccer: ok, remaining(å¯èƒ½ãªã‚‰), error
    æ³¨æ„: å®Ÿéš›ã«APIã«1å›ãšã¤GETã—ã¾ã™ï¼ˆæ—¥æ¬¡ã®è»½ã„ã‚¯ã‚¨ãƒªï¼‰ã€‚
    """
    api_key = os.environ.get("API_SPORTS_KEY", "").strip()
    key_set = bool(api_key)

    masked = None
    if key_set:
        head = api_key[:4]
        masked = f"{head}**** ({len(api_key)} chars)"

    def check_api(url: str, params: Dict[str, Any]) -> Dict[str, Any]:
        try:
            headers = {"x-apisports-key": api_key} if api_key else {}
            resp = requests.get(url, headers=headers, params=params, timeout=10)
            if resp.status_code == 200:
                remaining = resp.headers.get("x-ratelimit-requests-remaining") or resp.headers.get("x-ratelimit-remaining")
                return {"ok": True, "remaining": remaining}
            return {"ok": False, "error": f"HTTP {resp.status_code}"}
        except Exception as e:
            return {"ok": False, "error": str(e)}

    # ãã‚‡ã†ï¼ˆJSTï¼‰ã®è»½ã„ç–é€š
    today = dt.datetime.utcnow() + dt.timedelta(hours=9)
    date_str = today.strftime("%Y-%m-%d")

    mlb_status = {"ok": False, "error": "NO_KEY"}
    soccer_status = {"ok": False, "error": "NO_KEY"}
    if key_set:
        mlb_status = check_api(
            f"{MLB_API_BASE}/games",
            {"league": MLB_LEAGUE_ID, "season": today.year, "date": date_str, "timezone": "Asia/Tokyo"},
        )
        soccer_status = check_api(
            f"{SOCCER_API_BASE}/fixtures",
            {"date": date_str, "timezone": "Asia/Tokyo"},
        )

    return {
        "api_key_configured": key_set,
        "api_key_masked": masked,
        "mlb": mlb_status,
        "soccer": soccer_status,
        "timestamp": dt.datetime.utcnow().isoformat(),
    }

@app.get("/list_games")
async def list_games(date: Optional[str] = None, sport: str = "mlb"):
    """ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‹ã‚‰å¯¾æˆ¦ä¸€è¦§ã‚’è¿”ã™ï¼ˆdate=YYYY-MM-DD ä»»æ„ï¼‰"""
    sport = (sport or "mlb").lower()
    api_key_opt = os.environ.get("API_SPORTS_KEY", "").strip()
    manager = SoccerGameManager(api_key_opt) if sport == "soccer" else MLBGameManager(api_key_opt)
    games = None
    if date:
        try:
            ymd = date.replace("-", "")
            cache = manager.load_cache(f"games_{ymd}.json")
            if cache and isinstance(cache, dict):
                games = cache.get("games") or cache
        except Exception:
            games = None
    if games is None:
        games = manager.load_latest_cache() or []
    result = []
    for g in games or []:
        result.append({
            "id": g.get("id") or g.get("raw", {}).get("id"),
            "home": g.get("home"),
            "away": g.get("away"),
            "home_jp": g.get("home_jp"),
            "away_jp": g.get("away_jp"),
            "datetime": g.get("datetime"),
        })
    return {"count": len(result), "games": result}

@app.post("/debug/parse")
async def debug_parse(req: DebugParseRequest):
    """è²¼ã‚Šä»˜ã‘ãƒ†ã‚­ã‚¹ãƒˆã®è§£æçµæœã‚’è¿”ã™ï¼ˆãƒãƒƒãƒãƒ³ã‚°å‰ï¼‰"""
    games = parse_paste_text(req.text, req.sport)
    return games

@app.post("/npb_batch")
async def npb_batch_analysis(req: NPBBatchRequest):
    """NPBä¸€æ‹¬åˆ†æã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ"""
    try:
        # NPBãƒ†ã‚­ã‚¹ãƒˆè§£æ
        matches = parse_npb_batch_text(req.text)
        
        if not matches:
            raise HTTPException(status_code=400, detail="NPBè©¦åˆãƒ‡ãƒ¼ã‚¿ã‚’è§£æã§ãã¾ã›ã‚“ã§ã—ãŸ")
        
        # å„è©¦åˆã®EVåˆ†æ
        results = []
        for match in matches:
            try:
                # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ”ãƒŠã‚¯ãƒ«ã‚ªãƒƒã‚ºã§EVè¨ˆç®—ï¼ˆPersonalç³»ã¨åŒç­‰ï¼‰
                ev_result = evaluate_npb_match_with_defaults(match, req.rakeback, req.jp_odds)
                results.append({
                    "match": match,
                    "ev_result": ev_result,
                    "status": "success"
                })
            except Exception as e:
                results.append({
                    "match": match,
                    "error": str(e),
                    "status": "error"
                })
        
        return {
            "matches": matches,
            "results": results,
            "success_rate": f"{len([r for r in results if r['status'] == 'success'])}/{len(results)}"
        }
        
    except Exception as e:
        logging.error(f"NPB batch analysis error: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# --- GameIDResolverçµ±åˆã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ ---

class GameResolveRequest(BaseModel):
    sport: str
    team_a: str
    team_b: str
    date: Optional[str] = None

@app.get("/resolver/status")
async def resolver_status():
    """GameIDResolverã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’å–å¾—"""
    try:
        resolver = get_game_resolver()
        status = resolver.get_manager_status()
        sports = resolver.get_available_sports()
        
        return {
            "available_sports": sports,
            "manager_status": status,
            "timestamp": dt.datetime.utcnow().isoformat(),
            "status": "ready"
        }
    except Exception as e:
        return {
            "error": str(e),
            "status": "error",
            "timestamp": dt.datetime.utcnow().isoformat()
        }

@app.post("/resolver/game_id")
async def resolve_game_id(req: GameResolveRequest):
    """ãƒãƒ¼ãƒ åã‹ã‚‰è©¦åˆIDã‚’è§£æ±ºï¼ˆçµ±åˆç‰ˆï¼‰"""
    try:
        resolver = get_game_resolver()
        
        # æ—¥ä»˜è§£æ
        target_date = None
        if req.date:
            try:
                target_date = dt.datetime.strptime(req.date, "%Y-%m-%d")
            except ValueError:
                raise HTTPException(status_code=400, detail="Invalid date format. Use YYYY-MM-DD")
        
        # è©¦åˆIDè§£æ±º
        team_names = [req.team_a, req.team_b]
        game_info = resolver.resolve_game_id(req.sport, team_names, target_date)
        
        if not game_info:
            return {
                "success": False,
                "error": f"No game found for {team_names} in {req.sport}",
                "searched_teams": team_names,
                "sport": req.sport,
                "date": req.date
            }
        
        return {
            "success": True,
            "game_info": game_info,
            "searched_teams": team_names,
            "sport": req.sport,
            "date": req.date
        }
        
    except Exception as e:
        logging.error(f"Game ID resolution error: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/resolver/odds")
async def resolve_and_fetch_odds(req: GameResolveRequest):
    """ãƒãƒ¼ãƒ åã‹ã‚‰è©¦åˆIDã‚’è§£æ±ºã—ã¦ã‚ªãƒƒã‚ºã‚‚å–å¾—ï¼ˆãƒ¯ãƒ³ã‚¹ãƒˆãƒƒãƒ—ï¼‰"""
    try:
        resolver = get_game_resolver()
        
        # æ—¥ä»˜è§£æ
        target_date = None
        if req.date:
            try:
                target_date = dt.datetime.strptime(req.date, "%Y-%m-%d")
            except ValueError:
                raise HTTPException(status_code=400, detail="Invalid date format. Use YYYY-MM-DD")
        
        # ãƒ¯ãƒ³ã‚¹ãƒˆãƒƒãƒ—å‡¦ç†
        team_names = [req.team_a, req.team_b]
        result = resolver.resolve_and_fetch_odds(
            req.sport, 
            team_names, 
            target_date,
            bookmaker_ids=[4, 2]  # Pinnacle, Bet365
        )
        
        if not result:
            return {
                "success": False,
                "error": f"No game or odds found for {team_names} in {req.sport}",
                "searched_teams": team_names,
                "sport": req.sport,
                "date": req.date
            }
        
        # ã‚ªãƒƒã‚ºçµ±è¨ˆ
        bookmakers = result.get("bookmakers", [])
        total_bets = sum(len(bm.get("bets", [])) for bm in bookmakers)
        
        return {
            "success": True,
            "game_info": result.get("game_info"),
            "odds_summary": {
                "bookmaker_count": len(bookmakers),
                "total_bet_types": total_bets,
                "fetch_time": result.get("fetch_time")
            },
            "bookmakers": bookmakers,
            "searched_teams": team_names,
            "sport": req.sport,
            "date": req.date
        }
        
    except Exception as e:
        logging.error(f"Resolve and fetch odds error: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# ãƒ¡ã‚¤ãƒ³å®Ÿè¡Œ
if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8001)
